# codegen.py
# Pylance Strict Mode Compliant

from __future__ import annotations

import sys
from dataclasses import dataclass
from pathlib import Path
from typing import (
    Dict, List, Mapping, MutableMapping, Optional, 
    Sequence, Tuple, Union, cast, Any
)

import click
import wandb  # type: ignore[import-untyped]
import yaml
from jinja2 import Environment  # type: ignore[import-untyped]

# ----------------------------
# Types
# ----------------------------

JSONScalar = Union[str, int, float, bool, None]
JSONValue = Union[JSONScalar, 'JSONArray', 'JSONObject']
JSONArray = List[JSONValue]
JSONObject = Dict[str, JSONValue]

# ----------------------------
# Embedded Templates
# ----------------------------

PVC_TEMPLATE: str = """
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: "{{ run_name }}-pvc"
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  storageClassName: block-nvme-ord1
"""

JOB_TEMPLATE: str = """
apiVersion: batch/v1
kind: Job
metadata:
  name: "{{ run_name }}"
spec:
  backoffLimit: 2
  template:
    spec:
      restartPolicy: Never
      containers:
        - name: worker
          image: "{{ image_name }}"
          args:
            {% for key, value in config_items %}
            - "--{{ key }}"
            - "{{ value }}"
            {% endfor %}
          volumeMounts:
            - name: data-storage
              mountPath: /data
      volumes:
        - name: data-storage
          persistentVolumeClaim:
            claimName: "{{ run_name }}-pvc"
"""

README_TEMPLATE: str = """
# W&B Run: {{ run_name }} — Kubernetes Deployment Manifests

This directory contains the generated Kubernetes manifests to replicate the Weights & Biases run `{{ run_path }}` on a CoreWeave-like cluster.

## Overview

This proof-of-concept bridges ML experimentation (tracked in W&B) and production orchestration (Kubernetes). Generated by `wandb-k8s-codegen`.

Potential future UX:
```
wandb deploy --target coreweave --run {{ run_path }}
```

## Files
- `00-pvc.yaml` — PersistentVolumeClaim for workspace/storage.
- `01-job.yaml` — Kubernetes Job using container args derived from W&B run config.

## Deploy
```bash
# Ensure your kubectl context targets your cluster
kubectl apply -f .
kubectl get jobs
kubectl logs -f job/{{ run_name }}
```
"""

# ----------------------------
# Data Models
# ----------------------------

@dataclass(frozen=True)
class WandbRunData:
    id: str
    name: str
    path: str
    config: Dict[str, str]
    image: str


# ----------------------------
# W&B API Client
# ----------------------------

class WandbApiClient:
    def __init__(self) -> None:
        self.api = wandb.Api()  # type: ignore[no-untyped-call]

    def get_run_data(self, run_path: str) -> WandbRunData:
        try:
            run: Any = self.api.run(run_path)  # type: ignore[no-untyped-call, assignment]
        except Exception as e:
            raise RuntimeError(
                f"Failed to fetch W&B run at '{run_path}'. "
                "Check the path and your credentials."
            ) from e

        run_id: str = cast(str, getattr(run, "id", ""))  # type: ignore[arg-type]
        run_name: str = cast(str, getattr(run, "name", ""))  # type: ignore[arg-type]
        path_string: str = cast(str, getattr(run, "path_string", run_path))  # type: ignore[arg-type]
        cfg_raw = cast(MutableMapping[str, JSONValue], getattr(run, "config", {}))  # type: ignore[arg-type]

        default_image = "your-registry/your-training-image:latest"
        image_value = cfg_raw.get("docker_image", default_image)
        image: str = _to_str(image_value)

        config: Dict[str, str] = {
            k: _to_str(v) for (k, v) in cfg_raw.items()
            if not k.startswith("_")
        }

        if not run_id or not run_name:
            raise RuntimeError("W&B run did not include required fields (id/name).")

        return WandbRunData(
            id=run_id,
            name=run_name,
            path=path_string,
            config=config,
            image=image,
        )


# ----------------------------
# Manifest Generator
# ----------------------------

class ManifestGenerator:
    def __init__(self) -> None:
        self.env: Environment = Environment(autoescape=False)

    def _render(self, template: str, context: Mapping[str, object]) -> str:
        return self.env.from_string(template).render(**context)

    def generate(self, run: WandbRunData, output_dir: Path) -> None:
        output_dir.mkdir(parents=True, exist_ok=True)
        config_items: List[Tuple[str, str]] = sorted(run.config.items(), key=lambda kv: kv[0])
        context: Dict[str, object] = {
            "run_name": run.name,
            "run_path": run.path,
            "image_name": run.image,
            "config_items": config_items,
        }
        manifest_specs: Sequence[Tuple[str, str]] = (
            ("00-pvc.yaml", PVC_TEMPLATE),
            ("01-job.yaml", JOB_TEMPLATE),
            ("README.md", README_TEMPLATE),
        )
        for filename, tmpl in manifest_specs:
            rendered: str = self._render(tmpl, context)
            target = output_dir / filename
            if filename.endswith(".yaml"):
                loaded = yaml.safe_load(rendered)
                with target.open("w", encoding="utf-8") as f:
                    yaml.safe_dump(loaded, f, sort_keys=False)
            else:
                with target.open("w", encoding="utf-8") as f:
                    f.write(rendered)


# ----------------------------
# Utilities
# ----------------------------

def _to_str(value: JSONValue) -> str:
    if isinstance(value, (str, int, float, bool)) or value is None:
        return "" if value is None else str(value)
    dumped = yaml.safe_dump(value, sort_keys=False)
    return " ".join(dumped.strip().split())


# ----------------------------
# CLI
# ----------------------------

@click.command(help="Generate Kubernetes manifests from a Weights & Biases run.")
@click.argument("run_path", type=str)
@click.option(
    "--output-dir",
    "-o",
    default=None,
    type=click.Path(file_okay=False, path_type=Path),
    help="Directory to write generated files (defaults to ./<run_name>_k8s).",
)
def main(run_path: str, output_dir: Optional[Path]) -> None:
    click.echo("--- wandb-k8s-codegen ---")
    client = WandbApiClient()
    run_data = client.get_run_data(run_path)
    out_dir: Path = output_dir if output_dir is not None else Path(f"./{run_data.name}_k8s")
    ManifestGenerator().generate(run_data, out_dir)
    click.echo("\n--- Generation Complete ---")
    click.echo(f"Manifests saved to: {out_dir.resolve()}")
    click.echo("Review, then deploy with:")
    click.echo(f"\n  kubectl apply -f {out_dir}\n")


if __name__ == "__main__":
    try:
        main(standalone_mode=True)
    except SystemExit as e:
        if e.code not in (0, None):
            raise
    except Exception as exc:
        click.echo(f"\n!!! Error: {exc}", err=True)
        sys.exit(1)